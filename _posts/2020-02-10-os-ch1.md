---
title: OS - 개요
date: 2020-02-10 21:34:00
categories:
- Operating System
tags:
- OS
---

# 개요

1. [ 운영체제가 하는 일 ](#운영체제가-하는-일)
1. [ 컴퓨터 시스템의 구성 ](#컴퓨터-시스템의-구성)
1. [ 컴퓨터 시스템의 구조 ](#컴퓨터-시스템의-구조)
1. [ 운영체제의 구조 ](#운영체제의-구조)
1. [ 운영체제의 연산 ](#운영체제의-연산)
1. [ 프로세스 관리 ](#프로세스-관리)
1. [ 메모리 관리 ](#메모리-관리)
1. [ 저장장치 관리 ](#저장장치-관리)

## 운영체제가 하는 일
---

컴퓨터 시스템은 대게 네 가지 구성 요소인 **_하드웨어_**, **_운영체제_**, **_응용 프로그램_**, **_사용자_** 로 구분할 수 있다.

**_하드웨어_** 는 **중앙 처리 장치(CPU)**, **메모리**, **입출력장치(I/O)** 로 구성되어 기본 자원을 제공한다.

**_응용 프로그램_** 은 컴파일러, 웹 브라우저, 워드 프로세서등 사용자의 문제를 해결하기 위해 이들 자원이 어떻게 사용될지 정의한다.

**_운영체제_** 는 다른 프로그램이 유용한 작업을 할 수 있도록 기본 환경을 제공한다. 기본적으로 운영체제는 응용 프로그램에게 자원을 할당하고, 실행하고 있는 프로그램을 관리하는 역할을 수행한다.

![figure_1.1.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_1_SystemComponents.jpg)   

### 시스템관점에서의 운영체제
  
  - Resource Allocator
    - 컴퓨터 시스템은 사용자의 문제를 해결하기 위해 요구되는 CPU, 메모리, 저장공간, 입출력장치등의 하드웨어 및 소프트웨어 자원을 관리하는 관리자로써의 역할을 수행하며, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당한다.  
  - Control Program
    -  운영체제는 다양한 입출력 장치와 사용자 프로그램을 제어한다. 따라서 운영체제는 컴퓨터 시스템의 가장 기본적인 제어 프로그램이라고 할수 있으며, 컴퓨터 시스템의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다. 

## 컴퓨터 시스템의 구성
---

### 컴퓨터 시스템의 연산

현대의 범용 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결된 여러개의 장치 제어기와 하나 이상의 CPU로 구성되어 있다.

![figure_1.2.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_2_ModernSystem.jpg)

컴퓨터가 구동을 시작하기 위해, 가장 먼저 실행할 **부트스트랩 프로그램(Bootstrap Program)** 이 필요하다.
이 **부트스트랩 프로그램** 은 일반적으로 컴퓨터 내의 **ROM(Read Only Memory)** 이나 **EEPROM**에 저장되어 지며, 이를 **펌웨어** 라도로 한다. 이것은 CPI 레지스터로부터, 장치제어기, 메모리 내용등을 포함한 시스템의 모든 면을 초기화한다. 그리고 운영체제의 커널을 찾아 메모리에 적재한다.

운영체제의 커널이 적재 되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 있게 된다. 

일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되며 이는 부팅시 커널이 적재된후 같이 메모리에 적재되어 진다.
이 단계가 끝나면 시스템은 완전이 부트된 상태이며 시스템은 이벤트(event)가 발생하기를 기다린다.

사건이 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 **_인터럽트(Interrupt)_** 에 의해 신호가 보내어진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호는 보내 인터럽트를 발생시킬수 있다. 소프트웨어는 **_시스템 호출(System Call)_** 을 통해 인터럽트를 발생 시킬 수 있다. 

CPU가 인터럽트 되면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작주소를 자기고 있다. 그리고 **인터럽트 서비스 루틴** 이 실행된다. 인터럽트 서비스 루틴의 실행이 완료 되면, CPU는 인터럽트 되었던 연산을 재개한다.

![figure_1.2.2](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_3_InterruptTimeLine.jpg)  

인터럽트는 매우 빠르게 처리되어야 하고, 사용가능한 인터럽트의 수가 미리 정의 되어 있으므로, 인터럽트 루틴에 대한 포인들의 테이블을 이용할수 있다. 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출되어 질 수 있다. 이렇게 인터럽트 서비스 루틴의 주소를 제공하기 위해, 제공되는 배열을 **인터럽트 벡터** 라고 한다.


### 저장 장치 구조

CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하려면 프로그램이 반드시 메모리에 있어야 한다. 일반적인 컴퓨터 시스템은 대부분의 프로그램을 **주 메모리(RAM)** 이라 불리는 메모리에서 가져온다.

모든 형태의 메모리는 바이트의 배열을 제공한다. 각 바이트는 자신의 주소를 자지고 있으며, 상호작용은 특정 메모리 주소들에 대한 일련의 적재(load), 저장(store) 명령을 통하여 이루어 진다.

현대의 컴퓨터 시스템의 기본 아키텍쳐인 폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령은 **명령 레지스터(Instruction Register)** 에 저장한다. 이어서 명령을 해독하고, 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장할수 있도록 한다. 피 연산자에 대한 명령을 수행 한 후에 결과가 다시 메모리에 저장된다.

명령어 사이클의 종류는 아래와 같다.
  - Fetch Cycle(인출 사이클) 
    - 제어장치가 앞의 명령 실행을 완료한 후 다음에 실행할 명령을 기억 장치로부터 CPU로 가져오는 동작    을 완료할 때까지의 사이클
  - Indirect Cycle(간접 사이클)
    - 간접 주소 지정이 허용되는 경우 실행 사이클에 앞서 간접 사이클이 진행되는데, 오퍼랜드가 지정하는    곳으로부터 유효주소를 읽어들이기 위해 메모리에 접근하는 사이클
  - Execute Cycle(실행 사이클)
    - 인출된 명령어를 이용하여 직접 명령어를 실행하는 사이클
  - Interrupt Cycle(인터럽트 사이클)
    - 현재 수행중인 명령이 예기치 않은 일의 발생으로 중단되는 상태

저장창치의 종류는 아래와 같다.

![figure_1.2.3](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_4_StorageDeviceHierarchy.jpg)

### 입출력 구조

장치 제어기는 약간의 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다.

통상적으로 윤용체제는 각 장치 제어기마다 디바이스 드라이버를 가지고 있다. 이 디바이스 드라이버는 장치 제어기의 동작을 이해하도 운영체제의 다른 부분들에게 장치에 대한 일관된 인터페이스를 제공한다.

입출력 연산을 시작하기 위해, 디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재한다. 장치 제어기는, 취할 동작을 결정하기 위해 이들 레지스터의 내용을 조사한다. 제어기는 장치로부터 자신의 로컬버퍼로 데이터 전송을 시작한다. 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료 했음을 인터럽트를 이용하여 디바이스 드라이버에게 통보한다. 그렇게 되면 디바이스 드라이버는 제어를 운영체제에게 반환하고 이때 입력 완료인 경우에는 데이터 또는 데이터에 대한 포인터를 같이 반환할 수도 있다.

이 인터럽트 구동 방식의 입출력은 적은 데이터를 전송하는 데에는 문제가 없으나 대량의 데이터를 전송하는 데에는 성능에 저하가 일어난다. 이러한 문제를 해결하기 위해 **직접 메모리 접근(Direct Memory Access)** 장치가 사용된다.

![figure_1.2.4](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_5_HowItWorks.jpg)

## 컴퓨터 시스템의 구조
---

요즘날에 사용되는 **다중처리 시스템(MultiProcessor System)** 은 크게 두가지 형태를 가진다.

  - **비대칭적 다중 처리(Asymmetric Multiprocessing)**
    - 하나의 주 처리기가 시스템을 제어한다. 
    - 다른 처리기들은 주 처리기의 명령을 수행하거나 미리 정의된 작업을 수행한다.
    - 주종관계에 있으며, 주 처리기는 작업을 스케쥴링하고, 종속처리기에 작업을 할당한다.
  - **대칭적 다중 처리(Symmetric Multiprocessing)**
    - 대칭적 다중 처리(SMP)는 모든 처리기가 대등하다.
    - Window, Linux, MAC OS등 거의 모든 현대의 OS는 SMP를 지원한다.
    
| ![figure_1.3.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_6_SMP_Architecture.jpg) |
|:--:| 
| *대칭적 다중 처리 구조* |


현대의 CPU 설계 근황은 하나의 칩에 여러개의 코어를 포함시킨다. 이러한 구조의 다중처리 시스템을 멀티코어 시스템이라 한다.

| ![figure_1.3.2](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_7_DualCore.jpg) |
|:--:| 
| *멑티 코어 시스템* |


## 운영체제의 구조
---

운영체제의 핵심중 하나는 여러개의 프로그램을 실행할 수 있는 능력이다. 이를 **다중 프로그램(Multi Program)** 이라 한다. 

**다중 프로그래밍(MultiProgramming)** 은 CPU가 수행할 작업(코드와 데이터)을 항상 하나 가지도록 작업을 구상하여 CPU의 이용률을 증가시킨다.

| ![figure_1.4.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_9_MemoryLayout.jpg) |
|:--:| 
| *다중프로그래밍 시스템의 메모리 배치* |

**멀티태스킹(Multi Tasking)** 은 다중 프로그래밍의 논리적 확장이다. 멑티태스킹 시스템에서는 CPU가 다수의 작업들을 교대로 수행하지만, 매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안에 사용자는 각자 자기의 프로그램와 상호작용 할 수 있다.

  - Multi Programming
    - Throughput을 극대화
    - 작업도중에 User의 간섭 불가능
  - Multi Tasking
    - User 친화적

## 운영체제의 연산
---

현대의 OS는 **인터럽트 구동식(Interrupt Driven)** 이다.

컴퓨터 시스템에서 사건은 거의 항상 **인터럽트**나 **트랩**을 발생시켜 신호를 보낸다. 

트랩(예외)은 오류(0으로 나누기, 유요하지 않은 메모리 접근) 혹은 사용자 프로그램의 OS 서비스 수행 요청에 의해 유발되는 SW에 의해 생성된 인터럽트 이다.

### 이중 연산모드(Duel Operate)

OS의 적절한 동작을 보장하기 위해, OS 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다.\
이를 보장하기 위해 두개의 독립된 연산보드, 즉 **사용자 모드**와 **커널 모드**를 필요로 한다.\
두 모드를 구분하기 위해서 **모드 비트(Mode Bit)** 라 불리는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가된다. 

  - 커널 모드 : 0
  - 사용자 모드 : 1


시스템 부트 시, 하드웨어는 커넣모드에서 부터 시작된다. OS가 적재되고, 사용자 모드에서 사용자 프로세스가 실행된다.\
트랩이나 인터럽트가 발생할 때 마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다.

| ![figure_1.5.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_10_UserToKernelMode.jpg) |
|:--:|
| *사용자 모드에서 커널 모드로 변환* |

### 타이머

사용자 프로그램이 무한루프에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 OS로 복귀하지 않는 경우가 없도록 반드시 방지 해야한다. 이를 위해 **타이머(Timer)** 를 사용한다. 타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정한다.

## 프로세스 관리
---

하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 *수동적* 개체인 반면, 프로세스는 다음 수행할 명령을 지정하는 **프로그램 카운터(Program Counter)** 를 가진 *능동적* 인 개체이다.\
한 프로세스의 수행은 반드시 순차적이여야 한다.

OS는 프로세스 관리와 연관하여 아래와 같은 활동에 책임을 진다.

  - CPU에 프로세스와 스레드를 스케쥴링
  - 사용자 프로세스와 시스템 프로세스 생성 및 제거
  - 프로세스의 일시 중지와 재수행
  - 프로세스 동기화 제공
  - 프로세스 통신 제공 

## 메모리 관리
---

주 메모리는 CPU와 I/O 장치에 의해 공유되는 데이터의 저장소이다.

프로그램이 수행되기 위해선, 반드시 절대 주소로 매핑되어야 하고 메모리에 적재되어야 한다.

OS는 메모리 관리와 연관하여 아래와 같은 활동에 책임을 진다.

  - 현재 메모리의 사용현황 추적
  - 어떠한 프로세스들을 메모리에 적재하고 제거할 것인지 선정
  - 메모리 공간 할당 및 회수

## 저장장치 관리
---

파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다.

OS는 파일 관리와 연관하여 아래와 같은 활동에 책임을 진다.

  - 파일의 생성 및 제거
  - 디렉토리 생성 및 제거
  - 파일과 디렉토리를 조작하기 위한 프리미티브 제공
  - 파일을 보조 저장 장치로 매핑
  - 안정적인 저장 매체에 파일 백업

### 캐싱(Caching)

정보가 사용됨에 따라 보다 빠른 장치인 캐시에 일시적으로 복사된다.

| ![figure_1.8.1](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_11_StoragePerformance.jpg) |
|:--:|
| *저장장치의 각 단계별 성능* |

| ![figure_1.8.2](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_12_IntegerMigration.jpg) |
|:--:|
| *정수 A를 디스크에서 레지스터로 이동하는 과정* |

CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 가지고 있는 다중 처리기 환경에서 나타날 수 있는 문제는, \
A의 복사본이 동시에 여러 캐시에 존재 할 수 있다는 것 이다. 여러개의 CPU가 모두 동시에 실행될 수 있으므로, 한 캐시에 있는 A값이 갱신될 경우, A가 존재하는 모든 캐시에 즉각적으로 반영 되어야 한다. 이러한 문제를 **캐시 일관성** 문제라 한다.

### 입출력 시스템(I/O System)

OS의 목적중 하나는 사용자에게 특정 하드에어 장치의 특성을 숨기는 것이다.

일반적으로 입출력 시스템은 아래와 같이 구성된다.

  - 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
  - 일반적인 장치 드라이버 인터페이스
  - 특정 하드웨어 장치들을 위한 드라이버
